<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Street View Overlay - EINA</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				margin: 0px;
				overflow: hidden;
			}
		</style>
	</head>
	<body>

		
        <div id="streetviewpano" style="position: absolute; top:0; bottom:0; left:0; right:0; z-index: 0">  
        <div id="container" style="position: absolute; top:0; bottom:0; left: 0; z-index: 5000;">
          
        </div>
        </div>

		
		<!-- We do not use a sensor to establish the location of the user: 
		     must make explicit, important license issue -->
        <script type="text/javascript" src="http://maps.google.com/maps/api/js?sensor=false"></script>
        
        <script src="lib/jquery-2.0.3.js"></script>
        <script src="lib/jquery.mousewheel.js"></script>
		<script src="lib/three.min.js"></script>
		<script src="src/streetviewoverlay.js"></script>

		<script>
		var METERS2DEGREES = 0.0000125; // DO NOT USE THIS VALUE FOR 
            // ANY REAL DATA, IT IS JUST A QUICK, SIMPLISTIC, PRETTY BAD
            // APPROXIMATION
            
        // Translates degrees to meters. It is just a hack, not a proper projection.
        // originLat and originLon should be the "center" of our area of interest or
        // close to it    
        function hackMapProjection(lat, lon, originLat, originLon) {
            var lonCorrection = 1.5;
            var rMajor = 6378137.0;
        
            function lonToX(lon) {
                return rMajor * (lon * Math.PI / 180);
            }
        
            function latToY(lat) {
                if (lat === 0) {
                    return 0;
                } else {
                    return rMajor * Math.log(Math.tan(Math.PI / 4 + (lat * Math.PI / 180) / 2));
                }
            }
            
            var x = lonToX(lon - originLon) / lonCorrection;
            var y = latToY(lat - originLat);
            return {'x': x, 'y': y};
        }
        
        // ORIGEN FIJADO A CENTRO PARKING
        function latLon2ThreeMeters(lat, lon) {
            var xy = hackMapProjection(lat, lon, 41.684792, -0.888989);
            return {'x': xy.x, 'y': 0, 'z': -xy.y};
        }
        
		var jsonLoader = new THREE.JSONLoader();
        jsonLoader.load( "model3d/wheel.js", loadWheel );
        
		function loadWheel(geometry, materials) {
		    var mesh;
            mesh = new THREE.Mesh(geometry, 
                                      new THREE.MeshFaceMaterial(materials));
                                      
            //var altMaterial = new THREE.MeshBasicMaterial( { color: 0x777700, opacity: 0.8, transparent: true} );                                 
            //mesh = new THREE.Mesh(geometry, altMaterial);
            
            // Center of the parking lot behind Ada Byron building
            // more or less: 41.684792,-0.888989
            
            // Takes as center of the world (origin coordinates) the center of the parking lot
            meshPos =  latLon2ThreeMeters(41.684792, -0.888989);                         
                                                  
            mesh.geometry.computeBoundingBox();
            var xsize = mesh.geometry.boundingBox.max.x - mesh.geometry.boundingBox.min.x;
            var ysize = mesh.geometry.boundingBox.max.y - mesh.geometry.boundingBox.min.y;
            var zsize = mesh.geometry.boundingBox.max.z - mesh.geometry.boundingBox.min.z;

            var desiredXSize = 10; // meters
            var desiredYSize = 30; // meters
            var desiredZSize = 30; // meters
            
            mesh.scale.x = desiredXSize / xsize;
            mesh.scale.y = desiredYSize / ysize;
            mesh.scale.z = desiredZSize / zsize;
            
            mesh.position.x = meshPos.x;
            mesh.position.y = meshPos.y;
            mesh.position.z = meshPos.z;
            
            mesh.rotation.y = Math.PI/2;
            
            //console.log("current size: "+xsize+","+ysize+","+zsize);
            //console.log(mesh.scale);
            //console.log(mesh.position);
            
            // For shadows (given the right ligths, and that renderer enables them)
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            
            var streetViewOverlay = StreetViewOverlay();
             // 41.684196,-0.888992 is a street close to the parking lot behind Ada Byron building
            streetViewOverlay.load({streetView: true, objects3D: true}, mesh, 41.684196,-0.888992);           
        }

		</script>
	</body>
</html>
